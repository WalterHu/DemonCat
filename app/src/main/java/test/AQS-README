《AQS原理》
    AQS使用一个int变量state表示同步状态，使用一个隐式的FIFO同步队列(隐式队列就是并没有声明这样一个队列，
只是通过每个节点记录它的上个节点和下个节点来从逻辑上产生一个队列)来完成阻塞线程的排队。

这里FIFO队列的节点在AQS中被定义为一个内部类Node，Node的主要字段有：

    waitStatus：等待状态，所有的状态见下面的表格。
    prev：前驱节点
    next：后继节点
    thread：当前节点代表的线程
    nextWaiter：Node既可以作为同步队列节点使用，也可以作为Condition的等待队列节点使用(将会在后面讲Condition时讲到)。
                在作为同步队列节点时，nextWaiter可能有两个值：EXCLUSIVE、SHARED标识当前节点是独占模式还是共享模式；
                在作为等待队列节点使用时，nextWaiter保存后继节点。

     waiStatus说明
     状态	值	含义
     CANCELLED	1	当前节点因为超时或中断被取消同步状态获取，该节点进入该状态不会再变化
     SIGNAL	-1	标识后继的节点处于阻塞状态，当前节点在释放同步状态或被取消时，需要通知后继节点继续运行。每个节点在阻塞前，需要标记其前驱节点的状态为SIGNAL。
     CONDITION	-2	标识当前节点是作为等待队列节点使用的。
     PROPAGATE	-3
     0	0	初始状态

队列拥有首节点和尾节点，这两个节点分别保存于AQS的两个字段：head、tail。

    当一个线程想要获得同步状态的时候，如果当前有其他线程持有同步状态，当前线程将无法获取，
转而被构造为一个Node添加到同步队列的尾部，而这个加入的过程必须保证线程安全，因此同步器提供了一个基于CAS的设置队尾的方法：
compareAndSetTail(Node expect, Node update)，它需要传递当前线程"认为"的队尾。
在一个Node被CAS设置为队列之前，这个Node的prev已经被设置为之前的尾节点，
而在这个Node被设置为队尾之后，之前尾节点的next才会被指向这个Node。
因此在任一时刻，从head向后遍历队列不一定能遍历到tail，因为最后的tail可能还没有被倒数第二个节点指为next，
但是从tail向head遍历一定能遍历head。记住这个结论之后会用到。

在队列中，首节点是当前获取同步状态成功的节点，首节点在释放同步状态时，会唤醒后继节点，
而后继节点会在自己获取同步状态成功时，将自己设置为首节点。因为设置首节点是由持有同步状态的线程来完成的，
因此不需要使用CAS来保证线程安全，只需要持有同步状态的线程将首节点设置为原首节点的后继节点并断开原首节点的next引用即可。

《ReentrantLock》
ReentrantLock，即重入锁，是一个和synchronized关键字等价的，支持线程重入的互斥锁。只是在synchronized已有功能基础上添加了一些扩展功能。

除了支持可中断获取锁、超时获取锁、非阻塞获取锁这些显示锁的常见功能外，ReentrantLock还支持公平锁(synchronized只支持非公平锁)。
公平锁和非公平锁的区别就在于获取锁时候的逻辑略有不同，其他操作都是一样的，
因此公用的操作都放在Sync类里，NonfairSync和FairSync里只是实现自己的tryAcquire(int acquires)方法。

Sync类里有个诡异的nonfairTryAcquire方法，听名字是和非公平锁相关的，按道理应该放到NonfairSync类啊。
之所以有这么别扭的设计是为了服务tryLock()方法。
看一下ReentrantLock类的tryLock方法的实现，不管是公平锁还是非公平锁，调用的都是 nonfairTryAcquire 方法。
为什么这么实现呢？我们可以想一下tryLock() 的语义，tryLock() 要实现的效果是尝试获取一次锁，如果获取失败不阻塞而是直接返回false。
如果在公平锁模式下严格按照公平锁的定义来实现这个方法，那么当同步队列中有其他线程等待的时候，tryLock()都不可能获取到锁，只能返回false。
而事实上，当我们调用tryLock()的时候，很多时候应该都是希望尽可能的成功的，而此时要不要让tryLock()的线程严格排队，
其实不是那么重要，因此公平锁下tryLock()方法在获取锁时使用非公平获取模式，即可以插队。
