《AQS原理》
    AQS使用一个int变量state表示同步状态，使用一个隐式的FIFO同步队列(隐式队列就是并没有声明这样一个队列，
只是通过每个节点记录它的上个节点和下个节点来从逻辑上产生一个队列)来完成阻塞线程的排队。

这里FIFO队列的节点在AQS中被定义为一个内部类Node，Node的主要字段有：

    waitStatus：等待状态，所有的状态见下面的表格。
    prev：前驱节点
    next：后继节点
    thread：当前节点代表的线程
    nextWaiter：Node既可以作为同步队列节点使用，也可以作为Condition的等待队列节点使用(将会在后面讲Condition时讲到)。
                在作为同步队列节点时，nextWaiter可能有两个值：EXCLUSIVE、SHARED标识当前节点是独占模式还是共享模式；
                在作为等待队列节点使用时，nextWaiter保存后继节点。

     waiStatus说明
     状态	值	含义
     CANCELLED	1	当前节点因为超时或中断被取消同步状态获取，该节点进入该状态不会再变化
     SIGNAL	-1	标识后继的节点处于阻塞状态，当前节点在释放同步状态或被取消时，需要通知后继节点继续运行。每个节点在阻塞前，需要标记其前驱节点的状态为SIGNAL。
     CONDITION	-2	标识当前节点是作为等待队列节点使用的。
     PROPAGATE	-3
     0	0	初始状态

队列拥有首节点和尾节点，这两个节点分别保存于AQS的两个字段：head、tail。

    当一个线程想要获得同步状态的时候，如果当前有其他线程持有同步状态，当前线程将无法获取，
转而被构造为一个Node添加到同步队列的尾部，而这个加入的过程必须保证线程安全，因此同步器提供了一个基于CAS的设置队尾的方法：
compareAndSetTail(Node expect, Node update)，它需要传递当前线程"认为"的队尾。
在一个Node被CAS设置为队列之前，这个Node的prev已经被设置为之前的尾节点，
而在这个Node被设置为队尾之后，之前尾节点的next才会被指向这个Node。
因此在任一时刻，从head向后遍历队列不一定能遍历到tail，因为最后的tail可能还没有被倒数第二个节点指为next，
但是从tail向head遍历一定能遍历head。记住这个结论之后会用到。

在队列中，首节点是当前获取同步状态成功的节点，首节点在释放同步状态时，会唤醒后继节点，
而后继节点会在自己获取同步状态成功时，将自己设置为首节点。因为设置首节点是由持有同步状态的线程来完成的，
因此不需要使用CAS来保证线程安全，只需要持有同步状态的线程将首节点设置为原首节点的后继节点并断开原首节点的next引用即可。

《ReentrantLock》
ReentrantLock，即重入锁，是一个和synchronized关键字等价的，支持线程重入的互斥锁。只是在synchronized已有功能基础上添加了一些扩展功能。

除了支持可中断获取锁、超时获取锁、非阻塞获取锁这些显示锁的常见功能外，ReentrantLock还支持公平锁(synchronized只支持非公平锁)。
公平锁和非公平锁的区别就在于获取锁时候的逻辑略有不同，其他操作都是一样的，
因此公用的操作都放在Sync类里，NonfairSync和FairSync里只是实现自己的tryAcquire(int acquires)方法。

Sync类里有个诡异的nonfairTryAcquire方法，听名字是和非公平锁相关的，按道理应该放到NonfairSync类啊。
之所以有这么别扭的设计是为了服务tryLock()方法。
看一下ReentrantLock类的tryLock方法的实现，不管是公平锁还是非公平锁，调用的都是 nonfairTryAcquire 方法。
为什么这么实现呢？我们可以想一下tryLock() 的语义，tryLock() 要实现的效果是尝试获取一次锁，如果获取失败不阻塞而是直接返回false。
如果在公平锁模式下严格按照公平锁的定义来实现这个方法，那么当同步队列中有其他线程等待的时候，tryLock()都不可能获取到锁，只能返回false。
而事实上，当我们调用tryLock()的时候，很多时候应该都是希望尽可能的成功的，而此时要不要让tryLock()的线程严格排队，
其实不是那么重要，因此公平锁下tryLock()方法在获取锁时使用非公平获取模式，即可以插队。

《Condition》
Condition实现等待的时候内部也有一个等待队列，等待队列是一个隐式的单向队列，等待队列中的每一个节点也是一个AbstractQueuedSynchronizer.Node实例。
每个Condition对象中保存了firstWaiter和lastWaiter作为队列首节点和尾节点，每个节点使用Node.nextWaiter保存下一个节点的引用，因此等待队列是一个单向队列。
每当一个线程调用Condition.await()方法，那么该线程会释放锁，构造成一个Node节点加入到等待队列的队尾。

Condition只能配合独占类同步组件使，Condition的本质就是等待队列和同步队列的交互：
1.当一个持有锁的线程调用Condition.await()时，它会执行以下步骤：
2.构造一个新的等待队列节点加入到等待队列队尾
3.释放锁，也就是将它的同步队列节点从同步队列队首移除
4.自旋，直到它在等待队列上的节点移动到了同步队列（通过其他线程调用signal()）或被中断
5.阻塞当前节点，直到它获取到了锁，也就是它在同步队列上的节点排队排到了队首。

当一个持有锁的线程调用Condition.signal()时，它会执行以下操作：
1.从等待队列的队首开始，尝试对队首节点执行唤醒操作；如果节点CANCELLED，就尝试唤醒下一个节点；如果再CANCELLED则继续迭代。
2.对每个节点执行唤醒操作时，首先将节点加入同步队列，此时await()操作的步骤3的解锁条件就已经开启了。然后分两种情况讨论：
    a.如果先驱节点的状态为CANCELLED(>0) 或设置先驱节点的状态为SIGNAL失败，那么就立即唤醒当前节点对应的线程，此时await()方法就会完成步骤3，进入步骤4.
    b.如果成功把先驱节点的状态设置为了SIGNAL，那么就不立即唤醒了。等到先驱节点成为同步队列首节点并释放了同步状态后，会自动唤醒当前节点对应线程的，这时候await()的步骤3才执行完成，而且有很大概率快速完成步骤4.

《总结？
如果知道Object的等待通知机制，Condition的使用是比较容易掌握的，因为和Object等待通知的使用基本一致。
对Condition的源码理解，主要就是理解等待队列，等待队列可以类比同步队列，而且等待队列比同步队列要简单，因为等待队列是单向队列，同步队列是双向队列。
以下是笔者对等待队列是单向队列、同步队列是双向队列的一些思考，欢迎提出不同意见：
之所以同步队列要设计成双向的，是因为在同步队列中，节点唤醒是接力式的，由每一个节点唤醒它的下一个节点，如果是由next指针获取下一个节点，是有可能获取失败的，因为虚拟队列每添加一个节点，是先用CAS把tail设置为新节点，然后才修改原tail的next指针到新节点的。
因此用next向后遍历是不安全的，但是如果在设置新节点为tail前，为新节点设置prev，则可以保证从tail往前遍历是安全的。因此要安全的获取一个节点Node的下一个节点，先要看next是不是null，如果是null，还要从tail往前遍历看看能不能遍历到Node。
而等待队列就简单多了，等待的线程就是等待者，只负责等待，唤醒的线程就是唤醒者，只负责唤醒，因此每次要执行唤醒操作的时候，直接唤醒等待队列的首节点就行了。等待队列的实现中不需要遍历队列，因此也不需要prev指针。